6
1
0
0
故事开始（do_execve()开始执行）

3
1
1
eip[1]
15
0
查看端选择符是否是当前任务的选择符

1
1
2
eip1 & 0xffff
0x000f
15(0x000f)
0x000f
0
正式比较上一步中的两个值

3
1
1
namei
0x29780
0
读取当前程序结点指针

1
1
2
namei
inode
0x29780
0x29780
0
判断当前执行程序i节点是否与内存中i节点指针相同

3
1
1
imode
33225
0
读取imode准备之后的权限检查

3
1
1
euid
0
0
读取euid准备之后的权限检查

3
1
1
egid
0
0
读取egid准备之后的权限检查

5
1
3
imode
euid
判断函数
33225
0
逻辑运算
2
+
→
判断用户id是否有权限运行程序

5
1
3
imode
egid
判断函数
33225
0
逻辑运算
2
+
→
判断组id是否有权限运行程序

4
1
0
0
若无权限执行则报错

3
1
1
bh_>b_data[0,1]
#!
0
若有权限，继续执行，读取程序执行头

1
1
2
bh_>b_data[0,1]
#!
#!
#!
0
判断是否为脚本
_________________________________________（不是脚本）
1
1
2
sh_bang
判断标志
1
1
0
再次判断是不是脚本，若不是脚本需配置环境变量

6
1
0
0
本数据为非脚本程序产生的数据，则需要再次加载环境变量

6
1
0
0
进入copy_string()函数，复制指定个数的参数字符串到参数和环境空间中

2
2
2
get_ds()
new_fs
16
16
0
保存寄存器ds的值

2
2
2
get_fs()
old_fs
139264
139264
0
保存寄存器fs的值

3
2
1
from_kmem
1
0
读取标志，判断需要加载的字符串位置

1
2
2
from_kmem
标志
1
1
0
判断字符串是否在内核空间

2
2
2
new_fs
set_fs()
16
16
0
串指针在内核空间，fs指向内核空间

3
2
1
len
7
0
读取len和p，判断当前空间是否足够字符串复制

3
2
1
p
131067
0
读取len和p，判断当前空间是否足够字符串复制

9
2
1
新页面
新页面
0
（如果不够，则卡车运输新页面）

2
2
2
get_fs_byte()函数
fs指针对应页面
待复制字符串
待复制字符串
0
逐个字符调用get_fs_byte()函数复制字符串

6
2
0
0
第二段故事结束（复制了命令行参数到环境中）

6
2
0
0
再次运行copy_string()函数（复制了环境字符串到环境中）

6
1
0
0
之后工作为释放当前程序占用的资源并开始运行新程序

2
1
2
新程序i节点
current_>executable
inode
inode
0
让进程的executable字段指向新文件的i节点

6
1
0
0
让我们放轻松（调用free_page_tables()释放页面）

6
1
0
0
让我们创造新世界（调用create_tables()创建页面）

2
1
2
新文件各个字段
current中各个字段
string
string
0
把当前进程的各个字段替换为新文件的信息

2
1
2
ex.a_entry
eip[0]
0
0
0
将原系统中断的代码指针替换为新程序的入口点

2
1
2
p
eip[3]
67108816
67108816
0
将栈指针替换为新文件栈指针

6
1
0
0
程序运行结束！
