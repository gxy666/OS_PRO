6
1
0
0
故事开始（do_execve()开始执行）

3
1
1
eip[1]
15
0
查看端选择符是否是当前任务的选择符

1
1
2
eip1 & 0xffff
0x000f
15(0x000f)
0x000f
0
正式比较上一步中的两个值

3
1
1
namei
0x29780
0
读取当前程序结点指针

1
1
2
namei
inode
0x29780
0x29780
0
判断当前执行程序i节点是否与内存中i节点指针相同

3
1
1
imode
33225
0
读取imode准备之后的权限检查

3
1
1
euid
0
0
读取euid准备之后的权限检查

3
1
1
egid
0
0
读取egid准备之后的权限检查

5
1
3
imode
euid
判断函数
33225
0
逻辑运算
2
+
→
判断用户id是否有权限运行程序

5
1
3
imode
egid
判断函数
33225
0
逻辑运算
2
+
→
判断组id是否有权限运行程序

4
1
0
0
若无权限执行则报错

3
1
1
bh→b_data[0,1]
#!
0
若有权限，继续执行，读取程序执行头

1
1
2
bh_>b_data[0,1]
#!
#!
#!
0
判断是否为脚本
___________________________________________（是脚本）
3
1
1
buf
_
0
加载脚本解释段

7
1
1
bh
缓冲块及i节点
0
（释放缓冲块，释放i结点）

2
1
2
iput函数
环境参数块
inode
inode
0
把i结点放入环境参数块

8
1
2
清洗前
清洗后
/bin/bash _f
/bin/bash _f
0
（清洗脚本解释段buf）

1
1
2
buf
空串
/bin/bash _f
‘’
0
判断buf第一行是否为空

4
1
0
0
若buf第一行为空则报错

3
1
1
i_name
/bin/bash
0
若不为空则读取i_name中解释程序名

3
1
1
i_arg
_f
0
若不为空则读取i_arg中的程序参数

5
1
3
sh_bang
标记
sh_bang
0
0
1
2
+
=
将sh_bang加一，打标记，防止函数反复重启

6
1
0
0
进入copy_string()函数，复制指定个数的参数字符串到参数和环境空间中

2
2
2
get_ds()
new_fs
16
16
0
保存寄存器ds的值

2
2
2
get_fs()
old_fs
139264
139264
0
保存寄存器fs的值

3
2
1
from_kmem
1
0
读取标志，判断需要加载的字符串位置

1
2
2
from_kmem
标志
1
1
0
判断字符串是否在内核空间

2
2
2
new_fs
set_fs()
16
16
0
串指针在内核空间，fs指向内核空间

3
2
1
len
7
0
读取len和p，判断当前空间是否足够字符串复制

3
2
1
p
131067
0
读取len和p，判断当前空间是否足够字符串复制

9
2
1
新页面
新页面
0
（如果不够，则卡车运输新页面）

2
2
2
get_fs_byte()函数
fs指针对应页面
待复制字符串
待复制字符串
0
逐个字符调用get_fs_byte()函数复制字符串

6
2
0
0
第二段故事结束

6
2
0
0
再次运行copy_string()函数（再次运行复制脚本文件名）

6
2
0
0
再次运行copy_string()函数（再次运行复制解释文件程序名）

6
2
0
0
再次运行copy_string()函数（再次运行复制解释文件参数）

1
2
2
p
0
TRUE
FALSE
0
p为copy_string()函数返回值，若p为False，则报错

4
1
0
0
p为False说明copy_string()函数执行出错，返回

3
1
1
i节点
inode
0
读取i节点，在环境变量配置好的情况下返回并执行
___________________________________________________________（脚本结束）
3
1
1
imode
33152
0
读取imode准备之后的权限检查

3
1
1
euid
0
0
读取euid准备之后的权限检查

3
1
1
egid
0
0
读取egid准备之后的权限检查

5
1
3
imode
euid
判断函数
33152
0
逻辑运算
2
+
→
判断用户id是否有权限运行程序

5
1
3
imode
egid
判断函数
33152
0
逻辑运算
2
+
→
判断组id是否有权限运行程序

4
1
0
0
若无权限执行则报错

3
1
1
执行头
\v
0
若有权限，继续执行，读取程序执行头

1
1
2
执行头
#!
\v
#!
0
判断是否为脚本

6
1
0
0
由于已经执行完毕，sh_bang标记已经+1，不会再次进入脚本预处理程序
________________________________________________________________________（不是脚本）
1
1
2
sh_bang
判断标志
1
1
0
再次判断是不是脚本，若不是脚本需配置环境变量

6
1
0
0
本数据为脚本程序产生的数据，无需再次加载环境变量

6
1
0
0
之后工作为释放当前程序占用的资源并开始运行新程序

2
1
2
新程序i节点
current_>executable
inode
inode
0
让进程的executable字段指向新文件的i节点

6
1
0
0
让我们放轻松（调用free_page_tables()释放页面）

6
1
0
0
让我们创造新世界（调用create_tables()创建页面）

2
1
2
新文件各个字段
current中各个字段
string
string
0
把当前进程的各个字段替换为新文件的信息

2
1
2
ex.a_entry
eip[0]
0
0
0
将原系统中断的代码指针替换为新程序的入口点

2
1
2
p
eip[3]
67108816
67108816
0
将栈指针替换为新文件栈指针

6
1
0
0
程序运行结束！
